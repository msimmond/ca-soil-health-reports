---
title: "![](images/logo.png) `r params$project_name`</span><br> `r params$producer_name`"
subtitle: ""
params:
  producer_id: null
  year: null
  grouping_var: null
  data_path: null
  config: null
  dict_path: null
  project_name: "Soil Health Assessment Project"
  producer_name: "Producer Name"
  project_summary: "Thank you for participating in our soil health assessment project. This report provides detailed analysis of soil samples collected from your fields, including physical, chemical, biological, and carbon indicators of soil health."
  looking_forward: ""
  selected_indicators: null
  include_comparisons: true
  include_maps: true

# Shouldn't need to edit the below values unless you want to customize.
lang: en
execute:
  echo: false
  warning: false
  message: false
  output: true
knitr: 
  opts_chunk:
    dev: "ragg_png"
    tbl.cap: NULL
    ft.align: "left"
format: 
  html:
    toc: true
    toc-depth: 4
    toc-location: left
    link-external-newwindow: true
    embed-resources: true
    css: styles.css
  docx:
    reference-doc: inst/templates/report_template.docx
# output-dir: ../reports-rendered
format-links: false
fig-align: left
fig-width: 6
fig-height: 3.5
fig-dpi: 300
---

<!-- Attach soils package, set up paths -->

```{r setup}
# Soil health functions are now included directly in the app
library(dplyr)
library(tidyr)
library(flextable)
library(stringr)
library(openxlsx)
library(readxl)  # For reading Excel files
library(cowplot)
library(patchwork)
library(ggplot2)
library(ggpubr)
library(officer)
library(here)
library(testthat)
library(quarto)
library(ggiraph)
library(ggtext)

# Load soil health functions from the app
# Robustly find app root - works in both local and ShinyApps.io environments
find_app_root <- function() {
  # Method 1: Try to use config template path if available
  if (exists("params") && !is.null(params$config) && 
      !is.null(params$config$paths) && !is.null(params$config$paths$template)) {
    template_path <- params$config$paths$template
    if (file.exists(template_path)) {
      # Template path is relative to app root, so go up from quarto/ to app root
      template_dir <- dirname(normalizePath(template_path))
      if (basename(template_dir) == "quarto") {
        return(dirname(template_dir))
      }
    }
  }
  
  # Method 2: Start from current file location
  current_file <- tryCatch(knitr::current_input(), error = function(e) NULL)
  if (!is.null(current_file)) {
    start_dir <- tryCatch(dirname(normalizePath(current_file)), error = function(e) getwd())
  } else {
    start_dir <- getwd()
  }
  
  # Method 3: Look for app.R or renv.lock going up the directory tree
  dir <- start_dir
  max_depth <- 10
  depth <- 0
  
  while (depth < max_depth) {
    if (file.exists(file.path(dir, "app.R")) || 
        file.exists(file.path(dir, "renv.lock"))) {
      return(dir)
    }
    parent <- dirname(dir)
    if (parent == dir) break  # Reached filesystem root
    dir <- parent
    depth <- depth + 1
  }
  
  # Fallback: use current working directory
  return(getwd())
}

app_root <- find_app_root()

# Helper function to source files with error handling
# Use local = FALSE to source into global environment so functions are available in all chunks
src <- function(rel_path) {
  full_path <- file.path(app_root, rel_path)
  if (!file.exists(full_path)) {
    stop("Cannot find file: ", full_path, 
         "\nApp root: ", app_root,
         "\nCurrent dir: ", getwd())
  }
  source(full_path, local = FALSE)
}

src("R/helpers.R")
src("R/tables.R")
src("R/strip-plots.R")
src("R/texture-triangle.R")
src("R/map.R")

# Access all params
cfg         <- params$config
data_path   <- params$data_path
producer_id <- params$producer_id
year        <- params$year
grouping    <- params$grouping_var

# Debug wrapper removed for production

# Sanity checks to fail fast with a clear message
stopifnot(!is.null(cfg), !is.null(data_path), !is.null(producer_id), !is.null(year))

# Get output file type
out_type <- knitr::opts_knit$get("rmarkdown.pandoc.to")

# Figure directory (make fresh, then tell knitr)
fig_dir <- "figure-output"
if (fs::dir_exists(fig_dir)) fs::dir_delete(fig_dir)
fs::dir_create(fig_dir)
knitr::opts_chunk$set(fig.path = file.path(fig_dir, "fig-"))

# Path used by manual device writers below
path <- fig_dir

# Set reference document path for Word output
reference_doc <- file.path(app_root, "quarto", "inst", "templates", "report_template.docx")
```

<!-- Load data and dictionary -->

```{r load-data, include=FALSE}
# Load lab results from Excel or CSV file
file_ext <- tools::file_ext(params$data_path)
if (file_ext %in% c("xlsx", "xls")) {
  # For Excel files, check available sheets and use the data sheet
  sheets <- readxl::excel_sheets(params$data_path)
  # Available sheets: removed debug message
  
  # Use second sheet if multiple sheets exist (first is usually instructions)
  data_sheet <- if (length(sheets) >= 2) sheets[2] else sheets[1]
  # Using data sheet: removed debug message
  
  data <- readxl::read_excel(params$data_path, sheet = data_sheet) |> as.data.frame()
} else {
  # For CSV files, use read.csv as before
  data <- read.csv(
    params$data_path,
    check.names = FALSE,
    encoding = "UTF-8",
    strip.white = TRUE
  )
}

# Data loaded successfully

# Crop filtering is handled in the app UI, no need to filter here

# Data should already have standardized column names from the mapping
# Just ensure coordinates are numeric
if ("latitude" %in% names(data)) {
  data$latitude <- as.numeric(data$latitude)
}
if ("longitude" %in% names(data)) {
  data$longitude <- as.numeric(data$longitude)
}

# Abort if there are duplicate sample IDs.
if (anyDuplicated(data$sample_id)) {
  cli::cli_abort(c(
    "All values in {.var sample_id} must be unique.",
    "x" = "Found duplicate{?s} of\
                 {.val {unique(data$sample_id[duplicated(data$sample_id)])}}"
  ))
}
```

```{r load-dictionary, include=FALSE}
# Load data dictionary from Excel file or fallback
file_ext <- tools::file_ext(params$data_path)
if (file_ext %in% c("xlsx", "xls")) {
  # Read dictionary from "Data Dictionary" sheet in the same Excel file
  sheets <- readxl::excel_sheets(params$data_path)
  if ("Data Dictionary" %in% sheets) {
    dictionary <- readxl::read_excel(params$data_path, sheet = "Data Dictionary") |> as.data.frame()
    # Loaded dictionary from 'Data Dictionary' sheet
  } else {
    stop("Excel file must contain a 'Data Dictionary' sheet. Available sheets: ", 
         paste(sheets, collapse = ", "))
  }
} else {
  # For CSV files, use the old logic
  dictionary <- NULL
  if (!is.null(params$dict_path) && file.exists(params$dict_path)) {
    dictionary <- read.csv(params$dict_path, check.names = FALSE, fileEncoding = "UTF-8-BOM")
  } else {
    dictionary <- attr(data, "measurement_info")
    if (is.null(dictionary)) {
      # Dictionary attribute not found on data; falling back to file
      # Prefer an explicit path from config if you have it
      dict_path <- tryCatch(
        cfg$paths$data_dictionary,
        error = function(e) NULL
      )
      if (is.null(dict_path) || !file.exists(dict_path)) {
        # Final fallback to repo copy
        dict_path <- file.path(app_root, "quarto", "inst", "extdata", "data_dictionary_v3.csv")
      }
      if (!file.exists(dict_path)) {
        stop("Data dictionary not found. Tried cfg$paths$data_dictionary and ",
             "data/data_dictionary_v3.csv")
      }
      dictionary <- read.csv(dict_path, check.names = FALSE, fileEncoding = "UTF-8-BOM")
    }
  }
}

# Normalize expected columns / derived fields
if (!"abbr" %in% names(dictionary) && "abbreviation" %in% names(dictionary)) {
  dictionary$abbr <- dictionary$abbreviation
}

dictionary <- dictionary |>
  dplyr::mutate(
    # Concatenate abbr and unit with html break for the table and plot labels
    abbr_unit = glue::glue("{abbr}<br>{unit}"),
    # Set the order of how measurement groups will appear within the report
    # based on the order found in the data dictionary
    group_order = dplyr::cur_group_id(),
    # Set the order of how measurements will appear within each measurement
    # group based on the order found in the data dictionary
    measurement_order = seq_along(column_name),
    .by = measurement_group
  )

# Get vector of measurement groups from dictionary
measurement_groups <- unique(dictionary$measurement_group)
```

```{r data-validation}
# Column validation is handled during data upload, no need to check here

required_dict_cols <- c(
  "measurement_group",
  "column_name",
  "abbr",
  "unit"
)

# Check all column names in `data` are in the `required_cols` vector or
# Check that `dictionary` has required column names.
testthat::expect_contains(names(dictionary), required_dict_cols)

# Check that the measurement_groups are in the dictionary.
testthat::expect_in(measurement_groups, dictionary$measurement_group)
```

<!-- Set styling variables -->

```{r set-fonts-colors}
# Set fonts that work reliably on Shiny servers
# Use system fonts that are guaranteed to be available
header_font <- "Georgia"
body_font <- "Helvetica"  # Use Helvetica which is more likely to be available

# Flextable colors -----------------------------------------------------

# header background color
header_color <- "#023B2C"
# header text color
header_text_color <- "white"
# body darker background color
darker_color <- "#ccc29c"
# body lighter background color
lighter_color <- "#F2F0E6"
# border color
border_color <- "#3E3D3D"

# Map and plot colors -----------------------------------------------------

# point color for producer samples
primary_color <- "#a60f2d"
# point color for samples in same categories as producer
secondary_color <- "#3E3D3D"
# point color for all other samples in project
other_color <- "#ccc29c"

# facet strip background color
strip_color <- "#335c67"
# facet strip text color
strip_text_color <- "white"
```

<!-- Pivot data longer and join with data dictionary -->

```{r tidy-long}
# EDIT: `washi_data` example has soil measurements in columns 12 - 42. Replace
# this column range with the column indices of the soil measurements in your
# dataset.

# Tidy data into long format and join with data dictionary
# Only pivot columns that are in the data dictionary (measurements), excluding texture
measurement_cols <- dictionary$column_name[dictionary$column_name %in% names(data) & dictionary$column_name != "texture"]

results_long <- data |>
  dplyr::mutate(
    dplyr::across(
      # Only convert measurement columns to numeric
      all_of(measurement_cols),
      as.numeric
    )
  ) |>
  tidyr::pivot_longer(
    # Only pivot measurement columns, preserve metadata columns
    cols = all_of(measurement_cols),
    names_to = "measurement"
  ) |>
  dplyr::inner_join(dictionary, by = c("measurement" = "column_name")) |>
  dplyr::mutate(
    sample_id = sample_id, ### sample_id should already be created from mapping 
    group_order = factor(
      group_order,
      levels = unique(dictionary$group_order),
      ordered = unique(is.ordered(dictionary$group_order))
    ),
    abbr = factor(
      abbr,
      levels = dictionary$abbr,
      ordered = is.ordered(dictionary$measurement_order)
    ),
    abbr_unit = factor(
      abbr_unit,
      levels = dictionary$abbr_unit,
      ordered = is.ordered(dictionary$measurement_order)
    )
  ) |>
  dplyr::arrange(group_order, measurement_order) |>
  dplyr::filter(!is.na(value))
```

<!-- Get producer info -->

```{r get-producer-info}
# producer_id should not be blank - this would be caught in data validation

# Use the selected grouping variable for field_id if it exists
if (!is.null(params$grouping_var) && params$grouping_var %in% names(results_long)) {
  results_long$field_id <- results_long[[params$grouping_var]]
}



# Subset to producer samples - handle data type mismatches
producer_samples <- results_long |>
  dplyr::filter(producer_id == params$producer_id & 
                as.character(year) == as.character(params$year))

# Abort if there are no producer samples
if (nrow(producer_samples) == 0) {
  # Temporarily comment out the error to see what happens
  # cli::cli_abort(c(
  #   "i" = "Update {.code params} in YAML to a valid {.code producer_id} and\
  #   {.code year} combo.",
  #   "x" = "{.code {params$producer_id}} and {.code {params$year}} must exist\
  #    in your data."
  # ))
}

# Extract producer sample IDs, crops, counties, and farm name into
# producer list
# Extract producer info - use standard columns and selected grouping variable
producer_cols <- c("producer_id", "sample_id")
if (!is.null(params$grouping_var) && params$grouping_var %in% names(data)) {
  producer_cols <- c(producer_cols, params$grouping_var)
}
if ("crop" %in% names(data)) producer_cols <- c(producer_cols, "crop")

producer <- producer_cols |>
  rlang::set_names() |>
  purrr::map(\(x) pull_unique(
    df = producer_samples,
    target = x
  ))

# In case of multiple farm names, grab first one
#producer$farm_name <- if (producer$farm_name > 1) producer$farm_name[[1]]

# Keep all measurements for plotting - don't filter by producer's measurements
# (This allows "Other Fields" to show all available measurements from other producers)
```

<!-- GIS data prep -->

```{r prep-gis-df}
# Prep data for GIS table and map
# Use the selected grouping variable for labels, or sample_id as fallback
label_col <- if (!is.null(params$grouping_var) && params$grouping_var %in% names(producer_samples)) {
  params$grouping_var
} else {
  "sample_id"  # ultimate fallback
}

gis_df <- prep_for_map(
  producer_samples,
  label_heading = .data[[label_col]],
  # If crop is empty, omit from popup
  label_body = ifelse("crop" %in% names(producer) && !is.na(producer$crop), producer$crop, "")
)
```

<!-- Data wrangling for flextables -->

```{r calculate-averages}
# Always: Project Average
field_summary <- results_long |>
  dplyr::summarise(value = mean(value, na.rm = TRUE),
                   .by = c(measurement_group, abbr)) |>
  dplyr::mutate(label_val = "Project Average",
                `Field or Average` = "Project Average")

```

```{r combine-producer-and-summaries}
has_group <- !is.null(params$grouping_var) &&
             params$grouping_var != "" &&
             params$grouping_var %in% names(results_long)

group_var <- params$grouping_var

if (has_group) {
  # Preserve the factor order from the input (no label munging)
  if (is.factor(producer_samples[[group_var]])) {
    lvl <- levels(producer_samples[[group_var]])
    producer_samples[[group_var]] <- factor(producer_samples[[group_var]], levels = lvl)
  }

  # n fields per group (within producer+year)
  n_by_group <- producer_samples |>
    dplyr::distinct(sample_id, .data[[group_var]]) |>
    dplyr::count(.data[[group_var]], name = "n_fields")

  # mean by group (within producer+year)
  grower_summary <- producer_samples |>
    dplyr::summarise(
      value = mean(value, na.rm = TRUE),
      .by = c(measurement_group, abbr, .data[[group_var]])
    ) |>
    dplyr::left_join(n_by_group, by = group_var) |>
    dplyr::mutate(
      # Label = the exact group value + dynamic field count. No hard-coded words.
      `Field or Average` = glue::glue("{.data[[group_var]]}\n({n_fields} Fields)")
    ) |>
    dplyr::select(-n_fields)

} else {
  # No grouping selected → average of your producer's samples in that year
  n_samples <- dplyr::n_distinct(producer_samples$sample_id)
  grower_summary <- producer_samples |>
    dplyr::summarise(
      value = mean(value, na.rm = TRUE),
      .by = c(measurement_group, abbr)
    ) |>
    dplyr::mutate(
      `Field or Average` = glue::glue("Your Fields\nAverage\n({n_samples} Fields)")
    )
}

# Project Average - use all results if comparisons enabled, otherwise only Your Fields
# Also check if dataset actually has multiple producers (safety check)
n_producers <- length(unique(results_long$producer_id))
has_multiple_producers <- n_producers > 1

include_comparisons <- (is.null(params$include_comparisons) || params$include_comparisons) && has_multiple_producers

if (include_comparisons) {
  # Use all data for Project Average
  field_summary <- results_long |>
    dplyr::summarise(
      value = mean(value, na.rm = TRUE),
      .by = c(measurement_group, abbr)
    ) |>
    dplyr::mutate(`Field or Average` = "Project Average")
} else {
  # Only use Your Fields data for Project Average when comparisons are disabled
  field_summary <- results_long |>
    dplyr::filter(
      producer_id == params$producer_id,
      as.character(year) == as.character(params$year)
    ) |>
    dplyr::summarise(
      value = mean(value, na.rm = TRUE),
      .by = c(measurement_group, abbr)
    ) |>
    dplyr::mutate(`Field or Average` = "Project Average")
}

# Attach Texture only to Physical rows, keyed by the exact group value (no text edits)
if ("texture" %in% names(data) || "Texture" %in% names(data)) {
  tex_col <- intersect(c("texture","Texture"), names(data))

  if (has_group) {
    # Grouped case: texture by grouping variable
    texture_by_group <- data |>
      dplyr::filter(
        producer_id == params$producer_id,
        as.character(year) == as.character(params$year),
        !is.na(.data[[tex_col[1]]])
      ) |>
      dplyr::mutate(texture_upper = toupper(trimws(.data[[tex_col[1]]]))) |>
      dplyr::count(.data[[group_var]], texture_upper, name = "n") |>
      dplyr::group_by(.data[[group_var]]) |>
      dplyr::summarise(
        Texture = if (dplyr::n() == 1L) {
          # Only one texture type - just show the name without count
          dplyr::first(texture_upper)
        } else {
          # Multiple texture types - show with counts
          paste0(texture_upper, " (n = ", n, ")", collapse = ", ")
        },
        .groups = "drop"
      ) |>
      dplyr::rename(join_key = !!group_var)

    grower_summary <- grower_summary |>
      dplyr::mutate(
        # first line of the label is the raw group value we created above
        join_key = sub("\\n.*$", "", `Field or Average`)
      ) |>
      dplyr::left_join(texture_by_group, by = "join_key") |>
      dplyr::select(-join_key) |>
      dplyr::mutate(Texture = dplyr::if_else(measurement_group == "Physical", Texture, NA_character_))
  } else {
    # Ungrouped case: single texture value for "Your Fields"
    texture_value <- data |>
      dplyr::filter(
        producer_id == params$producer_id,
        as.character(year) == as.character(params$year),
        !is.na(.data[[tex_col[1]]])
      ) |>
      dplyr::mutate(texture_upper = toupper(trimws(.data[[tex_col[1]]]))) |>
      dplyr::count(texture_upper, name = "n") |>
      dplyr::arrange(dplyr::desc(n)) |>
      dplyr::summarise(
        Texture = if (dplyr::n() == 1L) {
          # Only one texture type - just show the name without count
          dplyr::first(texture_upper)
        } else {
          # Multiple texture types - show with counts
          paste0(texture_upper, " (n = ", n, ")", collapse = ", ")
        },
        .groups = "drop"
      ) |>
      dplyr::pull(Texture)
    
    # Add texture to grower_summary for Physical group only
    if (length(texture_value) > 0 && !is.na(texture_value)) {
      grower_summary <- grower_summary |>
        dplyr::mutate(
          Texture = dplyr::if_else(measurement_group == "Physical", texture_value, NA_character_)
        )
    }
  }
}

df_table <- dplyr::bind_rows(grower_summary, field_summary) |>
  dplyr::mutate(
    `Field or Average` = as.character(`Field or Average`),
    value = suppressWarnings(as.numeric(formatC(value, 2, drop0trailing = TRUE)))
  )
```

```{r split-into-groups}
# Split into list by measurement group and pivot wider safely
groups <- df_table |>
  split(df_table$measurement_group) |>
  purrr::imap(function(x, grp_name) {

    # If not Physical, drop Texture before the pivot so it doesn't become an id
    if (!identical(grp_name, "Physical") && "Texture" %in% names(x)) {
      x <- dplyr::select(x, -Texture)
    }

    # ID columns: Physical gets Texture as a second ID, others don't
    id_cols <- if (identical(grp_name, "Physical") && "Texture" %in% names(x)) {
      c("Field or Average", "Texture")
    } else {
      "Field or Average"
    }

    # Guard against duplicates → use mean, keep atomic columns
    x |>
      dplyr::summarise(
        value = mean(value, na.rm = TRUE),
        .by = c(all_of(id_cols), abbr)
      ) |>
      tidyr::pivot_wider(
        id_cols   = all_of(id_cols),
        names_from  = abbr,
        values_from = value,
        values_fill = NA_real_,
        values_fn   = mean
      ) |>
      # If any column still came out as list, flatten to first numeric
      dplyr::mutate(
        dplyr::across(
          where(is.list),
          ~ vapply(.x, function(z) if (length(z)) as.numeric(z[[1]]) else NA_real_, numeric(1))
        )
      )
  })

# Ensure Texture sits right after Field or Average in Physical
if ("Physical" %in% names(groups)) {
  phys <- groups$Physical
  if (all(c("Field or Average","Texture") %in% names(phys))) {
    groups$Physical <- phys[, c("Field or Average", "Texture", setdiff(names(phys), c("Field or Average","Texture")))]
  }
}

```

```{r physical-group-tweaks}
# Special wrangling for texture

# Extract physical df from averages list
physical <- list(Physical = groups$Physical)

# Remove texture from all dataframes except physical
groups <- purrr::map(
  subset(
    groups,
    !(names(groups) == "Physical")
  ),
  \(x) {
    if ("texture" %in% names(x)) {
      dplyr::select(x, -texture)
    } else {
      x
    }
  }
)

# Add physical df back to the averages list
groups <- c(groups, physical)

# Remove this intermediate variable from env
rm(physical)
```

```{r remove-rows-with-one-observation}
# Drop rows that truly indicate only one field in the label, e.g. "(1 Fields)"
tables <- groups |>
  purrr::map(\(x) {
    x |>
      dplyr::filter(!is.na(`Field or Average`)) |>
      dplyr::filter(!grepl("\\(\\s*1\\s*Fields\\s*\\)", `Field or Average`))
  })

tables <- tables[measurement_groups]
```

```{r get-headers-for-flextable}
# --- build a header mapping that matches each table's columns exactly (no data.table) ---
build_header <- function(tbl, hdr_from_dict, group_name) {
  # Some versions name the first col 'abbr', others 'label' – normalize
  if (!"label" %in% names(hdr_from_dict) && "abbr" %in% names(hdr_from_dict)) {
    hdr_from_dict <- dplyr::rename(hdr_from_dict, label = abbr)
  }

  # ID columns that should be in the header with blank units
  id_keys <- c("Field or Average",
               if (group_name == "Physical" && "Texture" %in% names(tbl)) "Texture" else NULL)

  id_rows <- data.frame(
    label = id_keys,
    key   = id_keys,
    unit  = "",
    stringsAsFactors = FALSE
  )

  # Keep only measurement columns that actually appear in this table
  meas_hdr <- hdr_from_dict |>
    dplyr::filter(key %in% names(tbl)) |>
    dplyr::select(label, key, unit)

  # Bind IDs + measurement headers, then order to match table columns
  out <- dplyr::bind_rows(id_rows, meas_hdr)
  out <- out[match(names(tbl), out$key), , drop = FALSE]

  # Fill any gaps defensively
  out$label[is.na(out$label)] <- out$key[is.na(out$label)]
  out$unit [is.na(out$unit )] <- ""

  out
}

# ---- rebuild 'headers' with the safe helper above ----
headers <- purrr::imap(tables, function(tbl, nm) {
  # you already have get_table_headers(dictionary, group) earlier
  hdr_from_dict <- get_table_headers(dictionary, nm)
  build_header(tbl, hdr_from_dict, nm)
})
```

```{r make-flextables}
# Quick diagnostic check for NA units
if (any(sapply(headers, function(h) any(is.na(h$unit))))) {
  warning("⚠️ Some header$unit entries are NA — replacing with empty strings")
  headers <- purrr::map(headers, \(h) dplyr::mutate(h, unit = ifelse(is.na(unit), "", unit)))
}

# Create a list containing a flextable for each measurement group
table_list <- list2DF(
  list(
    table = tables,
    header = headers
  )
) |>
  purrr::pmap(\(table, header) {
    make_ft(table, header) |>
      format_ft_colors(
        lighter_color = lighter_color,
        darker_color = darker_color
      ) |>
      style_ft(
        header_font = header_font,
        body_font = body_font,
        header_color = header_color,
        header_text_color = header_text_color,
        border_color = border_color
      ) |>
      unit_hline(header = header) |>
      flextable::set_table_properties(layout = "autofit")
  })
```

<!-- Plots -->

```{r prep-df-plot}
# Prep df for texture triangle and strip plots
# Add flag to identify "Your Fields" before summarization
results_long <- results_long |>
  dplyr::mutate(
    your_flag = producer_id == params$producer_id &
                as.character(year) == as.character(params$year)
  )


# Group by measurement metadata + selected grouping variable (NOT sample_id)
group_cols <- c("measurement", "measurement_group", "abbr", "unit", "abbr_unit")
if (!is.null(params$grouping_var) && params$grouping_var %in% names(results_long)) {
  # When grouping variable is selected, group by producer_id + grouping_var to get separate groups for each producer
  group_cols <- c(group_cols, "producer_id", params$grouping_var)
} else {
  # When no grouping variable, group by producer_id and year to create separate dots
  group_cols <- c(group_cols, "producer_id", "year")
}


# Calculate averages by group, carrying through the your_flag
results_long_summary <- results_long |>
  dplyr::summarize(
    value = mean(value, na.rm = TRUE),
    your_flag = any(your_flag),   # Carry the flag through summarization
    .by = all_of(group_cols)
  ) |>
  # Filter out groups that have no data or are invalid
  dplyr::filter(!is.na(value))


# Create plot dataframe with simple category assignment
df_plot <- results_long_summary |>
  dplyr::mutate(
    dummy = "dummy"  # For x-axis positioning
  )

# Determine the effective grouping variable (use sample_id as fallback)
effective_grouping_var <- if (!is.null(params$grouping_var) && 
                              params$grouping_var != "" &&
                              params$grouping_var %in% names(results_long_summary)) {
  params$grouping_var
} else {
  "sample_id"  # Fallback to sample_id if no grouping variable
}

# Add sample_id for compatibility with soils package functions
# Use a unique identifier for each aggregated group
df_plot <- df_plot |>
  dplyr::mutate(
    sample_id = paste0("group_", row_number())  # Unique ID for each aggregated group
  )

# Add category column using the your_flag
df_plot <- df_plot |>
  dplyr::mutate(
    category = ifelse(your_flag, "Your Fields", "Other Fields"),
    category = factor(category, levels = c("Your Fields", "Other Fields"))
  )


# Add plotting_group column for colors/symbols
if (!is.null(params$grouping_var) && params$grouping_var != "" && params$grouping_var %in% names(df_plot)) {
  # When grouping variable is selected, use it for plotting
  df_plot <- df_plot |>
    dplyr::mutate(
      plotting_group = dplyr::case_when(
        category == "Your Fields" ~ .data[[params$grouping_var]],
        TRUE ~ paste0("Other_", .data[[params$grouping_var]])  # Preserve original values for Other Fields
      )
    )
} else {
  # When no grouping variable, use category for plotting
  df_plot <- df_plot |>
    dplyr::mutate(
      plotting_group = category
    )
}

# Add label column based on plotting_group
df_plot <- df_plot |>
  dplyr::mutate(
    label = dplyr::case_when(
      category == "Your Fields" ~ glue::glue("{plotting_group}<br>{value} {unit}"),
      TRUE ~ glue::glue("{value} {unit}")
    )
  )

# Order so producer points are plotted on top
df_plot <- df_plot[order(df_plot$category, decreasing = TRUE), ]

# Normalize legend categories ("Your Fields" / "Other Fields") once
df_plot <- df_plot |>
  dplyr::mutate(
    category = ifelse(category %in% c("Your fields","Your Fields", "Producer Average"), "Your Fields",
                      ifelse(category %in% c("Other fields","Other Fields"), "Other Fields", category)),
    category = factor(category, levels = c("Your Fields", "Other Fields"))
  )

# Filter out "Other Fields" if comparisons are disabled OR if only one producer exists
if (!include_comparisons) {
  df_plot <- df_plot |>
    dplyr::filter(category == "Your Fields")
}
```

```{r prep-texture-triangle}
# --- Build texture data from the same filtered data used for strip plots ---

has_group <- !is.null(params$grouping_var) &&
             params$grouping_var != "" &&
             params$grouping_var %in% names(results_long)

# Check if texture components are available
has_texture_components <- any(results_long$abbr %in% c("Sand","Silt","Clay"))

if (has_texture_components) {
  # 1) Keep only texture measures
  tex_long <- results_long |>
    dplyr::filter(abbr %in% c("Sand","Silt","Clay")) |>
    dplyr::mutate(tex_name = tolower(abbr))

  # 2) Tag Your vs Other by producer + year
  tex_long <- tex_long |>
    dplyr::mutate(
      category = dplyr::case_when(
        producer_id == params$producer_id & as.character(year) == as.character(params$year) ~ "Your Fields",
        TRUE ~ "Other Fields"
      )
    )

# 3) Aggregation keys (what defines a single point)
#    Your Fields:  producer + year + (grouping var if present)
#    Other Fields: other producer + year + (grouping var if present)
your_keys  <- c("producer_id","year")
other_keys <- c("producer_id","year")
if (has_group) {
  your_keys  <- c(your_keys,  params$grouping_var)
  other_keys <- c(other_keys, params$grouping_var)
}

  # 4) Legend/plotting group (what drives symbol/color and legend text)
  #    Your Fields:  the selected grouping var value (e.g., treatment_id)
  #    Other Fields: constant "Other Fields"
  # Create legend_group column using if/else to avoid case_when evaluation issues
  if (has_group && !is.null(params$grouping_var) && params$grouping_var != "") {
    tex_long <- tex_long |>
      dplyr::mutate(
        legend_group = dplyr::case_when(
          category == "Your Fields" ~ as.character(.data[[params$grouping_var]]),
          TRUE ~ "Other Fields"
        )
      )
  } else {
    tex_long <- tex_long |>
      dplyr::mutate(
        legend_group = dplyr::case_when(
          category == "Your Fields" ~ "Your Fields",
          TRUE ~ "Other Fields"
        )
      )
  }

  # 5) Aggregate to one row per (category, key, legend_group, tex_name)
  agg <- tex_long |>
    dplyr::mutate(
      key = dplyr::if_else(
        category == "Your Fields",
        interaction(!!!syms(your_keys),  drop = TRUE),
        interaction(!!!syms(other_keys), drop = TRUE)
      )
    ) |>
    dplyr::summarize(
      value = mean(value, na.rm = TRUE),
      .by = c(category, key, legend_group, tex_name)
    ) |>
    tidyr::pivot_wider(names_from = tex_name, values_from = value) |>
    # plotting_group will be used for color/shape and legend matching
    dplyr::mutate(plotting_group = legend_group) |>
    dplyr::select(sand, silt, clay, category, plotting_group)

# Split lists used by the drawing code
texture_list <- split(agg, agg$category) |>
  purrr::map(\(df) dplyr::select(df, sand, silt, clay, plotting_group))

# Filter out "Other Fields" from texture_list if comparisons are disabled OR if only one producer exists
if (!include_comparisons) {
  texture_list <- texture_list[names(texture_list) == "Your Fields"]
}

# Producer must have at least one complete texture row
producer_texture <- dplyr::filter(agg, category == "Your Fields") |>
  dplyr::select(sand, silt, clay)

make_tt <- nrow(producer_texture) > 0 &&
           all(c("sand","silt","clay") %in% names(producer_texture)) &&
           any(stats::complete.cases(producer_texture[, c("sand","silt","clay")]))

} else {
  # If texture components are not available, set make_tt to FALSE
  make_tt <- FALSE
}
```

```{r make-texture-triangle, echo=FALSE, message=FALSE, warning=FALSE}
# Render and save the PNG
#png_path <- file.path(path, "texture-triangle.png")
#ragg::agg_png(png_path, res = 150, width = 1500, height = 1000, scaling = 1)

ragg::agg_png(
  "figure-output/texture-triangle.png",
  res = 150,
 # width = 1200,
  width = 1500,
  height = 1000,
  scaling = 1
)

make_texture_triangle(body_font = body_font)

.add_pts <- function(df, col, bg, pch, size) {
  if (!is.null(df) && nrow(df) > 0) {
    xyz <- df[, c("sand","silt","clay"), drop = FALSE]
    xyz <- xyz[stats::complete.cases(xyz), , drop = FALSE]
    if (nrow(xyz)) {
add_texture_points(xyz, color = col, bg = bg, pch = pch, size = size)
    }
  }
}

# Symbol/color maps
producer_groups <- if (!is.null(params$grouping_var) && params$grouping_var %in% names(producer_samples)) {
  unique(na.omit(producer_samples[[params$grouping_var]]))
} else character(0)

group_symbols <- c(22, 24, 23, 25, 21, 15, 16, 17)
group_colors  <- c(primary_color, "#023B2C", "#8B4513", "#4B0082",
                   "#FF6B35", "#2E8B57", "#9370DB", "#FFD700")
sym_map <- stats::setNames(group_symbols[seq_along(producer_groups)], producer_groups)
col_map <- stats::setNames(group_colors [seq_along(producer_groups)], producer_groups)

# Other fields - only add if comparisons are enabled AND multiple producers exist
if (include_comparisons && !is.null(texture_list$`Other Fields`)) {
  .add_pts(
    texture_list$`Other Fields`,
    col = paste0(as.character(other_color), "CC"),
    bg  = paste0(as.character(other_color), "99"),
    pch = 21,
    size = 1.36
  )
}

# Your fields
if (!is.null(texture_list$`Your Fields`)) {
  yf <- texture_list$`Your Fields`
  if (length(producer_groups)) {
    for (g in names(sym_map)) {
      .add_pts(
        dplyr::filter(yf, plotting_group == g),
        col = paste0(col_map[g], "FF"),
        bg  = paste0(col_map[g], "CC"),
        pch = sym_map[g],
        size = 2.4
      )
    }
  } else {
    .add_pts(yf,
      col = paste0(as.character(primary_color), "FF"),
      bg  = paste0(as.character(primary_color), "CC"),
      pch = 16, size = 2.4
    )
  }
}

# Legend - only include "Other Fields" if comparisons are enabled AND multiple producers exist
if (length(producer_groups)) {
  legend_items <- names(sym_map)
  legend_colors <- unname(col_map)
  legend_bg <- paste0(unname(col_map), "CC")
  legend_pch <- unname(sym_map)
  legend_size <- rep(2.4, length(sym_map))
  
  if (include_comparisons) {
    legend_items <- c(legend_items, "Other Fields")
    legend_colors <- c(legend_colors, as.character(other_color))
    legend_bg <- c(legend_bg, paste0(as.character(other_color), "99"))
    legend_pch <- c(legend_pch, 21)
    legend_size <- c(legend_size, 1.36)
  }
  
  add_legend(
    legend = legend_items,
    color  = legend_colors,
    pt.bg  = legend_bg,
    pch    = legend_pch,
    size   = legend_size,
    vertical_spacing = 1.5
  )
} else {
  if (include_comparisons) {
    add_legend(
      legend = c("Your Fields", "Other Fields"),
      color  = c(as.character(primary_color), as.character(other_color)),
      pt.bg  = c(paste0(as.character(primary_color), "CC"),
                 paste0(as.character(other_color), "99")),
      pch    = c(16, 21),
      size   = c(2.4, 1.36),
      vertical_spacing = 1.5
    )
  } else {
    add_legend(
      legend = "Your Fields",
      color  = as.character(primary_color),
      pt.bg  = paste0(as.character(primary_color), "CC"),
      pch    = 16,
      size   = 2.4,
      vertical_spacing = 1.5
    )
  }
}

invisible(dev.off())

# Optional trim
if (requireNamespace("magick", quietly = TRUE)) {
  tt <- magick::image_read("figure-output/texture-triangle.png")
  tt <- magick::image_trim(tt)
  magick::image_write(tt, "figure-output/texture-triangle.png")
}

# pass absolute path to child
#texture_png <- normalizePath(png_path, winslash = "/", mustWork = TRUE)


```

```{r make-strip-plots}
# Normalize categories once
df_plot <- df_plot |>
  dplyr::mutate(
    category = dplyr::case_when(
      category %in% c("Your fields", "Your Fields") ~ "Your Fields",
      category %in% c("Other fields", "Other Fields") ~ "Other Fields",
      TRUE ~ as.character(category)
    ),
    category = factor(category, levels = c("Your Fields", "Other Fields"))
  )

# Tidy long titles if needed
df_plot$abbr_unit <- dplyr::recode(df_plot$abbr_unit,
  "Aggregate Stability Index*<br>" = "Aggregate Stability<br>Index*<br>"
)

# Precompute producer groups and shared symbol/color maps
producer_groups <- if (!is.null(params$grouping_var) &&
                        params$grouping_var %in% names(producer_samples)) {
  unique(na.omit(producer_samples[[params$grouping_var]]))
} else character(0)

group_symbols <- c(22, 24, 23, 25, 21, 15, 16, 17)
group_colors  <- c(primary_color, "#023B2C", "#8B4513", "#4B0082",
                   "#FF6B35", "#2E8B57", "#9370DB", "#FFD700")

sym_map <- stats::setNames(group_symbols[seq_along(producer_groups)], producer_groups)
col_map <- stats::setNames(group_colors [seq_along(producer_groups)], producer_groups)

# One strip plot per measurement group
plot_list <- df_plot |>
  split(df_plot$measurement_group) |>
  purrr::map(\(group) {
    if (!is.null(params$grouping_var) &&
        params$grouping_var != "" &&
        params$grouping_var %in% names(group)) {

      # Use category to determine symbols/colors instead of grouping variable
      # This ensures "Your Fields" and "Other Fields" get distinct symbols
      group <- group |>
        dplyr::mutate(
          plotting_group = dplyr::case_when(
            category == "Your Fields" ~ .data[[params$grouping_var]],
            category == "Other Fields" ~ "Other Fields",
            TRUE ~ "Other Fields"
          )
        )

      # Only include "Other Fields" in legend if comparisons are enabled AND multiple producers exist
      legend_levels <- if (include_comparisons) {
        c(producer_groups, "Other Fields")
      } else {
        producer_groups
      }
      group$plotting_group <- factor(group$plotting_group, levels = legend_levels)

      p <- make_strip_plot(
        group,
        id = sample_id,
        color = plotting_group,
        fill  = plotting_group,
        size  = plotting_group,
        shape = plotting_group,
        alpha = plotting_group,
        language = "English"
      )

      # Lock styles & order to shared maps
      p <- set_dynamic_scales(
        p, group, "plotting_group", producer_groups,
        primary_color = primary_color, other_color = other_color
      )
      
      # Build scale values based on what's in legend_levels
      color_values <- col_map
      fill_values <- stats::setNames(base::paste0(unname(col_map), "CC"), names(col_map))
      shape_values <- sym_map
      size_values <- stats::setNames(rep(2.5, length(producer_groups)), producer_groups)
      alpha_values <- stats::setNames(rep(1, length(producer_groups)), producer_groups)
      
      if (include_comparisons) {
        color_values <- c(color_values, "Other Fields" = as.character(other_color))
        fill_values <- c(fill_values, "Other Fields" = base::paste0(as.character(other_color), "99"))
        shape_values <- c(shape_values, "Other Fields" = 21)
        size_values <- c(size_values, "Other Fields" = 2.5)
        alpha_values <- c(alpha_values, "Other Fields" = 0.8)
      }
      
      p <- p +
        scale_color_manual(
          values = color_values,
          limits = legend_levels
        ) +
        scale_fill_manual(
          values = fill_values,
          limits = legend_levels
        ) +
        scale_shape_manual(
          values = shape_values,
          limits = legend_levels
        ) +
        scale_size_manual(
          values = size_values,
          limits = legend_levels
        ) +
        scale_alpha_manual(
          values = alpha_values,
          limits = legend_levels
        )

    } else {
      # No grouping var chosen → conditionally include "Other Fields" in legend
      legend_levels <- if (include_comparisons) {
        c("Your Fields", "Other Fields")
      } else {
        "Your Fields"
      }
      
      p <- make_strip_plot(
        group,
        id = sample_id,
        color = plotting_group,
        fill  = plotting_group,
        size  = plotting_group,
        shape = plotting_group,
        alpha = plotting_group,
        language = "English"
      )
      
      if (include_comparisons) {
        p <- p +
          scale_shape_manual(values = c("Your Fields" = 16, "Other Fields" = 16),
                             limits = legend_levels) +
          scale_colour_manual(values = c("Your Fields" = as.character(primary_color),
                                         "Other Fields" = as.character(other_color)),
                              limits = legend_levels) +
          scale_fill_manual(values   = c("Your Fields" = base::paste0(as.character(primary_color), "CC"),
                                         "Other Fields" = base::paste0(as.character(other_color), "99")),
                            limits = legend_levels) +
          scale_alpha_manual(values  = c("Your Fields" = 1, "Other Fields" = 0.8),
                             limits = legend_levels) +
          scale_size_manual(values   = c("Your Fields" = 2.5, "Other Fields" = 2.5),
                            limits = legend_levels)
      } else {
        p <- p +
          scale_shape_manual(values = c("Your Fields" = 16),
                             limits = legend_levels) +
          scale_colour_manual(values = c("Your Fields" = as.character(primary_color)),
                              limits = legend_levels) +
          scale_fill_manual(values   = c("Your Fields" = base::paste0(as.character(primary_color), "CC")),
                            limits = legend_levels) +
          scale_alpha_manual(values  = c("Your Fields" = 1),
                             limits = legend_levels) +
          scale_size_manual(values   = c("Your Fields" = 2.5),
                            limits = legend_levels)
      }
    }

    p + theme_facet_strip(
      body_font = body_font,
      strip_color = strip_color,
      strip_text_color = strip_text_color
    )
  })
```

## `r producer$farm_name`

{{< include 03_project-summary.qmd >}}

`r if (is.null(params$include_maps) || params$include_maps) "## Your Fields" else ""`

```{r}
#| eval: !expr is.null(params$include_maps) || params$include_maps
# do not add chunk label due to bug
# https://github.com/quarto-dev/quarto-cli/issues/3603

# Use the selected grouping variable for the table header
table_header <- if (!is.null(params$grouping_var)) {
  if (params$grouping_var == "treatment_id") {
    "Treatment ID"
  } else if (params$grouping_var == "field_id") {
    "Field ID"
  } else {
    stringr::str_to_title(gsub("_", " ", params$grouping_var))
  }
} else {
  "Sample ID"
}

gis_ft <- gis_df |>
  dplyr::select(
    !!table_header := .data[[label_col]],
    Longitude = longitude,
    Latitude = latitude
  )

# If Crop exists and has any NAs, drop it from the printed table
if ("Crop" %in% names(gis_ft) && any(is.na(gis_ft$Crop))) {
  gis_ft <- gis_df |>
    dplyr::select(-Crop)
}


# If longitude/latitude have any NAs, drop those columns from the printed table
if (any(is.na(gis_ft$Longitude)) || any(is.na(gis_ft$Latitude))) {
  cols_keep <- setdiff(names(gis_ft), c("Longitude", "Latitude"))
  gis_ft <- gis_ft[, cols_keep, drop = FALSE]
}

gis_ft |>
  flextable::flextable() |>
style_ft(header_font = header_font, body_font = body_font) |>
  flextable::set_table_properties(layout = "autofit")
```

<!-- The below "\" is a hard line break that works for html and docx. -->

\

```{r html-map}
#| eval: !expr out_type == "html" && (is.null(params$include_maps) || params$include_maps)

# Render interactive map only when we have complete coords + package available + maps enabled
include_maps <- is.null(params$include_maps) || params$include_maps
has_coords <- ("longitude" %in% names(gis_df)) && ("latitude" %in% names(gis_df)) &&
              all(!is.na(gis_df$longitude)) && all(!is.na(gis_df$latitude))

if (include_maps && has_coords && requireNamespace("leaflet", quietly = TRUE)) {
make_leaflet(
    gis_df,
    primary_color = primary_color
  )
}
```

```{r static-map}
#| eval: !expr out_type == "docx" && (is.null(params$include_maps) || params$include_maps)
#| out-width: 6in

# Static map only when coords present AND required packages are available AND maps enabled
include_maps <- is.null(params$include_maps) || params$include_maps
pk_ok <- all(c(
  requireNamespace("sf", quietly = TRUE),
  requireNamespace("maptiles", quietly = TRUE),
  requireNamespace("tidyterra", quietly = TRUE),
  requireNamespace("ggrepel", quietly = TRUE)
))

has_coords <- ("longitude" %in% names(gis_df)) && ("latitude" %in% names(gis_df)) &&
              all(!is.na(gis_df$longitude)) && all(!is.na(gis_df$latitude))

if (include_maps && pk_ok && has_coords) {
  # Deduplicate by coordinates to avoid multiple labels at same location
  df_sf <- gis_df |>
    dplyr::distinct(longitude, latitude, .keep_all = TRUE) |>
    sf::st_as_sf(
      coords = c("longitude", "latitude"),
      crs = 4326
    ) |> sf::st_transform(3857)

  df_sf_buffered <- sf::st_buffer(df_sf, dist = 1000)
  buffered_bbox <- sf::st_bbox(df_sf_buffered)

  basetiles <- maptiles::get_tiles(
    df_sf_buffered,
    provider = "Esri.WorldImagery",
    cachedir = tempdir(),
    retina = TRUE
  )

  map <- ggplot2::ggplot(df_sf) +
    tidyterra::geom_spatraster_rgb(data = basetiles) +
    ggplot2::geom_sf(color = primary_color, size = 3) +
    ggrepel::geom_label_repel(
      ggplot2::aes(label = .data[[label_col]], geometry = geometry),
      stat = "sf_coordinates",
      family = body_font,
      size = 3,
      point.padding = 2,
      min.segment.length = 0
    ) +
    ggplot2::coord_sf(
      crs = 3857,
      xlim = c(buffered_bbox["xmin"], buffered_bbox["xmax"]),
      ylim = c(buffered_bbox["ymin"], buffered_bbox["ymax"])
    ) +
    ggplot2::theme_void()

  ggplot2::ggsave(glue::glue("{path}/map.png"), map, dpi = 300)
}
```

{{< pagebreak >}}

## Project Results

`r params$project_results`

```{r create-measurement-group-sections}
#| output: asis

# DO NOT RUN THIS CHUNK INTERACTIVELY. See
# https://wa-department-of-agriculture.github.io/soils/articles/troubleshoot.html#error-when-run-interactively.

# If the report fails to render at this chunk, interactively run all chunks
# above this one, open `02_section-template.qmd`, uncomment the first
# troubleshoot chunk, and then run each chunk in the file interactively to
# debug.

# Add section for each measurement group containing a header, texture triangle
# (for the physical group), table, and plot.
sections <- purrr::map_chr(measurement_groups, \(group) {
  knitr::knit_child(
    input = "02_section-template.qmd",
    envir = environment(),
    quiet = TRUE
  )
})

cat(sections, sep = "\n")

```{r download-data-text}
#| eval: !expr out_type == "html"
#| output: asis

# Add a download section if downloadthis is installed
if (requireNamespace("downloadthis", quietly = TRUE)) {
  cat("## Download your data")
}
```

```{r download-data}
#| eval: !expr out_type == "html"

# Add a data download button if downloadthis is installed
if (requireNamespace("downloadthis", quietly = TRUE)) {
  list(
    results = dplyr::filter(data, producer_id == params$producer_id),
    measurement_dictionary = dictionary[
      ,
      c(
        "column_name",
        "abbr",
        "unit"
      )
    ]
  ) |>
    downloadthis::download_this(
      output_name = glue::glue("{params$year}-soils-data"),
      output_extension = ".xlsx",
      button_label = "Download as Excel spreadsheet",
      button_type = "success"
    )
}
```

```{r looking-forward-conditional, echo=FALSE, results='asis'}
# Only show Looking Forward section if user provided content
if (!is.null(params$looking_forward) && 
    !is.na(params$looking_forward) && 
    trimws(params$looking_forward) != "") {
  cat("## Looking Forward\n\n")
  cat(params$looking_forward)
  cat("\n\n")
  cat("![](images/pic2.png){width=\"4in\" fig-alt=\"Photo of soil in a shovel.\"}")
}
```

<!-- Please do not remove the acknowledgement. -->

## Acknowledgement

{{< include 09_acknowledgement.qmd >}}

{{< pagebreak >}}

## Indicator Reference List
{{< include 04_soil-health-background.qmd >}}
